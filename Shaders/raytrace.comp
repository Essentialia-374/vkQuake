#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_ray_query : enable

layout (set = 0, binding = 0, rgb10_a2) uniform writeonly image2D output_image;
layout (set = 0, binding = 1) uniform accelerationStructureEXT tlas;

layout (push_constant) uniform PushConsts
{
        vec2  screen_size_rcp;
        float aspect_ratio;
        float origin_x;
        float origin_y;
        float origin_z;
        float forward_x;
        float forward_y;
        float forward_z;
        float right_x;
        float right_y;
        float right_z;
        float down_x;
        float down_y;
        float down_z;
}
push_constants;

layout (local_size_x = 8, local_size_y = 8) in;

const vec3 LIGHT_POSITION = vec3 (200.0f, 200.0f, 200.0f);
const vec3 LIGHT_COLOR = vec3 (1.0f, 0.95f, 0.85f);
const vec3 AMBIENT_COLOR = vec3 (0.05f);

vec3 base_color_from_primitive (uint primitive_index)
{
        const vec3 palette[5] = vec3[](vec3 (0.75f, 0.30f, 0.25f), vec3 (0.20f, 0.55f, 0.75f), vec3 (0.60f, 0.60f, 0.30f), vec3 (0.45f, 0.35f, 0.70f), vec3 (0.65f, 0.55f, 0.45f));
        return palette[primitive_index % 5u];
}

void main ()
{
        const uint pos_x = gl_GlobalInvocationID.x;
        const uint pos_y = gl_GlobalInvocationID.y;

        vec3 color = vec3 (0.02f, 0.02f, 0.04f);

        const float pos_x_unit = ((float (pos_x) * push_constants.screen_size_rcp.x) * 2.0f) - 1.0f;
        const float pos_y_unit = ((float (pos_y) * push_constants.screen_size_rcp.y) * 2.0f) - 1.0f;
        const vec3 origin = vec3 (push_constants.origin_x, push_constants.origin_y, push_constants.origin_z);
        const vec3 forward = vec3 (push_constants.forward_x, push_constants.forward_y, push_constants.forward_z);
        const vec3 right = vec3 (push_constants.right_x, push_constants.right_y, push_constants.right_z) * push_constants.aspect_ratio;
        const vec3 down = vec3 (push_constants.down_x, push_constants.down_y, push_constants.down_z);
        const vec3 direction = normalize (forward + (right * pos_x_unit) + (down * pos_y_unit));

        rayQueryEXT ray_query;
        rayQueryInitializeEXT (ray_query, tlas, gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT, 0xFF, origin, 1e-3f, direction, 1e30f);

        while (rayQueryProceedEXT (ray_query))
        {
        }

        if (rayQueryGetIntersectionTypeEXT (ray_query, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
        {
                const float distance = rayQueryGetIntersectionTEXT (ray_query, true);
                const vec3 hit_position = origin + direction * distance;

                vec3 v0;
                vec3 v1;
                vec3 v2;
                rayQueryGetIntersectionTriangleVertexPositionsEXT (ray_query, true, v0, v1, v2);

                const vec3 object_normal = normalize (cross (v1 - v0, v2 - v0));
                const mat3 world_to_object = mat3 (rayQueryGetIntersectionWorldToObjectEXT (ray_query, true));
                const mat3 normal_matrix = transpose (world_to_object);
                const vec3 normal = normalize (normal_matrix * object_normal);

                const vec3 light_vector = LIGHT_POSITION - hit_position;
                const float light_distance = length (light_vector);
                const vec3 light_direction = light_vector / max (light_distance, 1e-3f);

                float shadow = 1.0f;
                rayQueryEXT shadow_query;
                const vec3 shadow_origin = hit_position + normal * 1e-2f;
                rayQueryInitializeEXT (
                        shadow_query, tlas,
                        gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT,
                        0xFF, shadow_origin, 1e-3f, light_direction, light_distance - 2e-2f);
                while (rayQueryProceedEXT (shadow_query))
                {
                }
                if (rayQueryGetIntersectionTypeEXT (shadow_query, true) != gl_RayQueryCommittedIntersectionNoneEXT)
                {
                        shadow = 0.0f;
                }

                const vec3 base_color = base_color_from_primitive (rayQueryGetIntersectionPrimitiveIndexEXT (ray_query, true));
                const float ndotl = max (dot (normal, light_direction), 0.0f);
                const float attenuation = 1.0f / (1.0f + 0.01f * light_distance);
                color = AMBIENT_COLOR * base_color + base_color * LIGHT_COLOR * ndotl * attenuation * shadow;
        }

        imageStore (output_image, ivec2 (pos_x, pos_y), vec4 (clamp (color, 0.0f, 1.0f), 1.0f));
}
